
9、接口
9.1抽象类&抽象方法：
（1）有抽象类的需求，对抽象类进行实例化是无意义的，将此行为视为错误，并且在编译期就报出。
将抽象类中的空方法，声明为abstract,例如abstract void f()，称之为抽象方法
包含抽象方法的类为抽象类，创建抽象类的实例，会在编译器报错。
（2）继承抽象类时需要实现所有的抽象方法。（如果没有实现所有，那么子类也是抽象类，且编译器会
强制coder使用abstract来修饰这个类。
（3）创建一个没有抽象方法的类：满足下面两个需求时①不需要有抽象方法②需要规定该类不能有实例
9.2接口
（1）抽象类中的抽象方法，没有具体实现，对实现类进行了一定的要求（实现规定了返回值、参数列表、方法名的抽象方法）
这个可以说是抽象类中的接口部分，同时抽象类中还有已经实现的一些方法，实现类可以直接继承。
（2）接口是一个完全抽象的类，没有任何实现供实现类继承。使用interface这个关键字。
（3）接口表示：所有实现了本接口的类都应该具备本接口描述的特征。
即在面向对象设计时，可以通过面向接口设计，来解耦，与接口绑定而不与具体的类绑定，增加扩展性与灵活性。
使用接口的一方知道可以调用接口的所有方法。
所以interface的方法默认为public，实现接口时，要注明实现的接口中的方法为public，否则接口的访问限制将被缩小为protected
会导致编译错误。

总结：无论抽象类还是接口，都是可以向上转型的。因为接口/抽象类的子类都有相同的行为。


2017-08-16
9.3解耦
接口可以降低耦合性：
涉及类、方法时：方法参数应该是接口，而不是具体的类。
当一个方法的参数是一个类时，后续的只能操作该类的继承关系的类型。这样绑定得过于紧密。大多数时候没必要。
参数是一个接口的话，可以极大的减少耦合性。

Java编程思想中的例子非常具有代表性。

在面向接口编程的过程中，可以首先定义一个接口，规定类型的行为。然后再做一个实现该接口的抽象类，将公共的
部分实现，其他的具体的业务设置为抽象方法，交给实现类实现。将需要接口中子类实现的方法，声明成abstract。

接口中的方法默认是public
域默认是public static的

子类可以将父类中的protected方法放大到public吗？demo测试可以。
修改返回值类型是重载吗？不行，编译期报错；重写的话，参数、返回值、方法名必须完全一致。
